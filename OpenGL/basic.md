
1. 图形的渲染管线

	* 顶点变化：在vertex shader中处理顶点数据
	* 细分着色器：使用patch描述物体的形状，并且使用简单的patch几何体完成细分工作
	* 几何着色器：几何着色器处理图元，可以把原始顶点数据进行更新；
	* 图元组装：根据draw的绘制命令，把一个个的顶点组装成响应图元，一般都来说都是组装为三角形图片；
	* 剪切：对于落在viewport之外的顶点clipping掉，由OpenGL自动完成
	* 光栅化：硬件会光栅化视景体范围内的图元信息，使其变为一个个的像素
	* 模板测试：根据模板测试里的信息，保证模板测试成功的片元通过，失败的则不进入片元着色器
	* 片元着色器：处理每个片元，进行一些shading算法，完成片元颜色的计算
	* 深度测试：保存当前深度值最小的片元到缓冲区中，深度测试失败的片元将抛弃
	* 混合：与原始缓冲区的颜色进行混合为最终颜色

2. OpenGL的缓冲区有哪些，作用是什么？
	
	* 顶点缓存：vertex buffer 主要用来保存顶点数据，传入结合顶点给顶点着色器
	* 帧缓存 frame buffer：主要用来离屏渲染，实现RTT和MRT技术
	* 深度缓存：depth buffer： 用于深度测试，保存输出结果不至于错乱
	* 模板缓存：stencil buffer：用于模板测试，保证模板测试成功的片元才存在，用于减少不必要的计算
	* 颜色缓存：color buffer：用于保存shading的结果，通常frame buffer都有10几个color buffer挂载点
	* UBO（uniform buffer）： 以结构体的方式传入变量到GPU中，比单一uniform方式更加高效，不过同样UBO是不能修改的；
	* SSBO：Shader Storage Buffer Object 传入一些数据到GPU，不过这里SSBO可以动态增长，而且可以被修改，这是相比于UBO的优势
	* PBO： 像素缓存区，用于保存像素数据，结合glmapbuffer直接地址获取，可以实现快速buffer的初始化

3. OpenGL的坐标变化的几个矩阵有哪些，作用是什么？

	* World矩阵：建模师提供几何模型，几何一开始的顶点数据是以自己的局部坐标作为参考，但是一个场景有世界坐标系，以世界原点为重心，world矩阵就是把几何顶点数据转换到世界坐标系中
	* View矩阵：相机camera的视景体就是我们看到的场景区域，view矩阵把世界顶点转换到view坐标系下；
	* Projection矩阵：投影矩阵作用是把三维顶点投影到二维平面，投影方式分为透视投影和正交投影，透视投影更符合现实生活中的近大远小的规律，而正交投影保持几何模型大小不变，通常用于
	CAD中。

4. 说新版OpenGL和老版OpenGL的区别
	
	主要是固定管线和可编程管线的区别。老版OpenGL使用固定管线，在cpp代码中通常使用glBegin和glEnd等设置一些状态，而且功能较单一。而可编程管线加入了着色器，图形程序员可以自由
	控制管线的处理逻辑，其中管线还加入细分着色器，几何着色器等，可以更加全面和灵活处理渲染流程。

	在新版OpenGL中，还加入了各种特性，如原子着色器，UBO，SSBO等缓冲区，可以完成一些算法功能需求。
	
5. 纹理Alpha的混合方式（原理和公式）

	假设一种不透明东西的颜色是A，另一种透明的东西的颜色是B，那么透过B去看A，看上去的颜色C就是B和A的混合颜色。 通常混合方式分为完全不透明，完全透明，不透明混合，这里设置B
	的透明度为alpha(取值0-1,0表示完全透明，1表示完全不透明)

	```c++
	R(C)=alpha*R(B)+(1-alpha)*R(A)
	G(C)=alpha*G(B)+(1-alpha)*G(A)
	B(C)=alpha*B(B)+(1-alpha)*B(A)
	```

	应用alpha混合技术，可以实现出最眩目的火光、烟雾、阴影、动态光源等等一切你可以想象的出来的半透明效果。


6. GLSL的shader如何使用？

	* 创建着色器: glCreateShader
	* 着色器文本关联到着色器id：glShaderSource
	* 编译着色器：glCompileShader
	* 获取编译是否成功：glGetShaderiv(GL_COMPILE_STATUS), 
	* 获取编译失败的原因：glGetShaderInfoLog

	* 创建着色器程序： glCreateProgram
	* 依附着色器代码：glAttachShader(m_ShaderProgram, ShaderObject); 通常来说着色器是vertex shader和 fragment shader组成，所以这里需要依附两个着色器；
	* 连接着色器程序： glLinkProgram
	* 获取着色器程序连接状态：glGetProgramiv(m_ShaderProgram, GL_LINK_STATUS, &Success);
	* 获取连接失败的原因：glGetProgramInfoLog(m_ShaderProgram, 1024, NULL, ErrorLog);

	* 最后删除shader：glDeleteShader
	* 具体使用着色器时候：glUseProgram(shaderId)
	* 程序结束后释放着色器：glDeleteProgram(m_ShaderProgram);

7. GLSL如何传递数据？

	* 外部CPU传递数据给GPU：使用uniform统一变量，外部使用函数glUniform***()传递值，注意uniform是const属性，不能在着色器中被修改；
	* attribute变量：只能在vertex shader使用，使用glBindAttribLocation绑定每个属性的位置，然后使用glVertexAttribPointer为每个变量赋值，通常用于
	传递几何模型的顶点，纹理坐标，法线到顶点着色器中；
	* 着色器之间的数据传递：老版OpenGL中通过varying变量声明，不过现在都用out和in关键字表面输入和输出，注意的是变量命名需完全相同；

8. 两圆相交，只有2交点A、B，过A点做线段CAD，CA、AD为两圆的弦，问什么情况下CAD最长，并证明。

	连接BC，BD。当CAD不断的变化的时候，可以得到个无数个三角形CBD，这些三角形的夹BCA和角BDA都是相同的，分别是BA对应的圆心角的一半。
	这些三角形都是相似的。那么当BD最大的时候，也就是三角形最大的时候，也就是CAD最长的时候。 BD最大的时候就是BD为圆的直径，则BAD为直角，同理，BAC也是直角=>BA 垂直CAD。

9. 顶点法线和面法线的作用

	* 面法线：平面法线垂直于平面，通常有三角形两两之间的顶点的矢量叉乘得来，OpenGL规定是以逆时针的方向叉乘得来的为正方形。 经常用于flat着色。
	* 顶点法线：因为一个顶点可能处于多个平面贡献，比如金字塔模型。所以顶点法线的计算通常是各个平面法线的均值。点的法线是在使用Phone或Gouraud模型时计算光照使用，
	每个顶点法线不同，会实现更加平滑的效果。

10. 着色方法

	Flat、Gouraud和Phong。这三种方法分别基于多边形、顶点和像素来计算光照效果。

	* Flat着色处理方法以三角形为单位进行颜色计算，然后用各种颜色对三角形进行填充。
	* Gouraud着色处理方法首先计算三角形每个顶点处的光照，然后用顶点颜色通过插值来计算三角形内部各点的光照。
	* Phong着色处理方法用三角形过顶点处的法向量通过插值的方式计算每个像素处的法向量，然后根据各个像素的法向量计算光照效果。

11. 平面上N个点，每两个点都确定一条直线， 求出斜率最大的那条直线所通过的两个点（斜率不存在的情况不考虑）时间效率越高越好。

	假如A,B,C三个点水平顺序放置，如果AB的斜率为x，那么AC的斜率一定是小于AB的。 所以基于这个思路可以先把所有顶点按照x的方向进行排序，而排序最快的
	时间复杂度为N*log(N)。

	* N个点按x坐标排序
	* 遍历，求相邻的两个点的斜率，找最大值

12. mipmap的作用

	MIP map技术与材质贴图技术结合，根据距观看者远近距离的不同，以不同的分辨率将单一的材质贴图以多重图像的形式表现出来并代表平面纹理：
	尺寸最大的图像放在前面显著的位置，而相对较小的图像则后退到背景区域。
	mipmap level 0表示原始纹理，根据每一级增高，宽高都减1/2,所以分辨率减少为1/4。

13 怎么判断一个点在三角形内

	* 面积法： 如果点在三角形内部，形成的三个子三角形面积和等于最外部的三角形；
	* 内角和法：连接P点到三个顶点，形成PA,PB,PC，如果与三角形各边形成的夹角和为180，那么在三角形内部；
	* 同向法：如果点p在三角形内部，沿着三角形边走一圈，点p和该边对应点都在边的同侧；所以只需要验证两点在线段同侧？
	  通过叉乘实现验证，连接p点和A,B,C三点，PA和AB，CA和AB都分别做叉乘，如果正负性相同说明在同侧，如果不一致就不是同侧。然后继续验证其他两边边，最后
	  都在同侧说明在三角形内部。
	* 重心法：三角形共面，所以平面内一点可以表示P = A +  u * (C – A) + v * (B - A) 。如果三角形在内部，只需要满足u>=0,v>=0,并且u+v<=1。 
	带入顶点数据解方程即可算出u和v因子。
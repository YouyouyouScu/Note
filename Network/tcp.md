
# TCP 协议

TCP(Transmission Control Protocol), 传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层（Transport Layer）通讯协议。
应用层向TCP层发送用于网间传输的，用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（不能超过数据链路层**最大传输单元MTU**）。之后TCP把结果包传给
IP层，由它通过网络将包传送给接收端实体的TCP层。TCP为了保证不丢包，就为每个包设定一个**序号**，同时序号也保证了接收端实体的包按序接收。然后接收端实体对接收到的包
发挥一个相应**ACK**；如果发送端实体在合理的**往返时延（RTT)**内未收到确定，那么对应的数据包就被假设已丢失进行重传。TCP使用一个**检验和（Checksum）**来检验数据是否有错
，在发送和接收时都要计算校验和。

## TCP 结构

## TCP 状态流转

![][1]

1. CLOSED: 初始状态
2. LISTEN: 服务端处于监听状态
3. STN_SENT: 客户端处于发送状态，等待服务端确认；
4. SYN_RCVD: 表示服务端收到SYN报文；
5. ESTABLISHED: 表示连接已经建立；
6. FIN_WAIT_1：请求终止连接，等待对方的FIN报文；
7. FIN_WAIT_2： 服务端表示暂时还有数据发送，稍后再关闭连接；
8. TIME_WAIT: 客户端收到FIN报文并发出ACK报文，等待**2MSL**后回到CLOSED；
9. CLOSING: 客户端发送FIN报文，不是先收到服务端的ACK报文，而是收到了FIN报文，即两端同时进行了关闭连接；
10. CLOSE_WAIT: 等待关闭，服务端等待数据发送完的状态；
11. LAST_ACK: 服务端发送FIN 报文后等待ACK报文；
12. CLOSED: 服务端收到ACK报文后，进入CLOSED可用状态


## TCP 重传机制

在异常网络（超市或丢包）时，TCP通过超时重传控制可靠的数据传输。异常情况：

* 发送端发送的数据包丢失；
* 接收端回传ACK包丢失；
* 接收端异常未正常响应，ACK被接收端丢失；

如果发送端没有收到接收端回传的ACK报文，客户端会重发数据，如何设置**重传超时时间(Retransmission TimeOut)**,RTO指客户端发送数据后，重传数据前等待接受方收到该数据
报告ACK的时间。

#### TCP 超时重传

TCP协议必须适应两个方面差异：

* 达到不同目的端的时延差异；
* 统一连接上的传输时延随业务量负载的变化而出现的差异；

TCP协议使用自适应算法以适应分组传输时延的变化，引入了RTT(Round Trip Time)，也就是连接往返时间，发送端发送TCP包到开始到接收它的立即响应所消耗的传输时间。
重传时间为1s, 2s, 4s, 8s，以2的指数级增长。

#### TCP 快重传

超时重传是发送端在傻等超时，然后触发重传；而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。当客户端收到服务端3次相同ACK报文时，则触发重传。

## TCP 滑动窗口


## TCP 拥塞控制

某段时间内，若对网络中某一个资源的请求超过该资源所能提供的可用部分，网络性能变坏，这种情况叫拥塞。而**拥塞控制**是防止过多的数据注入网络中，使网络中的路由器或链路不致过载。

### 慢开始和拥塞避免

### 快重传和快恢复


## TCP 流量控制



## 思考
* TCP和UDP区别

	TCP是面向连接，可靠的，有序的，缓慢的传输层协议。传输数据之前需通过三次握手建立连接，发送数据无差错，不丢失，不重复。而且发送是字节流
	，并在服务端排序保证数据有序性。因为TCP的各种机制导致传输缓慢，适用于金融方面，点到点通信应用。TCP头部大小20字节。

	UDP是面向无连接，不可靠，无序的，快速传输层协议。传输过程无需建立连接，发送数据报，存在丢包的情况，是一种高速的传输协议，适用于游戏和视频会议
	领域。UDP头部8字节。

* 为什么说TCP是可靠连接？

	TCP发送数据时，要求另外一端返回确认。如果在规定时间没收到确认，那么TCP发送端会重发数据并等待更长时间，数次重传失败后才会放弃。TCP的重传机制保证了可靠性。

* TCP四次分手中，主动关闭方最后为什么要等待2MSL之后才关闭连接？

* 为什么是三次握手连接，而不是二次连接？
	
	防止失效的请求报文段又传送到服务端，造成服务端资源浪费。
	客户端发起的连接请求由于网络时延没能及时达到服务器，而客户端等待一段时间重新发送连接请求且建立成功。 而过后失效的连接请求到达服务器，服务器以为是客户端又重新发送的新连接，服务端同意连接并向客户端发回确认。此时客户端不予理会，从而服务端等待客户端发送数据，造成了服务端资源浪费。

* 为什么是四次断开连接，而不是三次断开？
	
	关闭连接时，客户端发送FIN报文给服务端，仅仅表示客户端没有数据发送给服务端了。但此时服务端可能数据还没传输完，所以不能立即关闭连接，需要发送ACK表示关闭请求已经收到，待服务端发送完数据给客户端后再发送FIN报文表示服务端也要关闭连接，此时客户端再发回ACK，表示成功关闭连接。

## TCP 网络编程

  TODO

[1]: tcp_state.png
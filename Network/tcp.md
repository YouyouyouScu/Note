
# TCP 协议

TCP(Transmission Control Protocol), 传输控制协议，是一种面向连接的，可靠的，基于字节流的传输层（Transport Layer）通讯协议。
应用层向TCP层发送用于网间传输的，用8位字节表示的数据流，然后TCP把数据流分割成适当长度的报文段（不能超过数据链路层**最大传输单元MTU**）。之后TCP把结果包传给
IP层，由它通过网络将包传送给接收端实体的TCP层。TCP为了保证不丢包，就为每个包设定一个**序号**，同时序号也保证了接收端实体的包按序接收。然后接收端实体对接收到的包
发挥一个相应**ACK**；如果发送端实体在合理的**往返时延（RTT)**内未收到确定，那么对应的数据包就被假设已丢失进行重传。TCP使用一个**检验和（Checksum）**来检验数据是否有错
，在发送和接收时都要计算校验和。

## TCP 结构

## TCP 状态流转

![][1]

1. CLOSED: 初始状态
2. LISTEN: 服务端处于监听状态
3. STN_SENT: 客户端处于发送状态，等待服务端确认；
4. SYN_RCVD: 表示服务端收到SYN报文；
5. ESTABLISHED: 表示连接已经建立；
6. FIN_WAIT_1：请求终止连接，等待对方的FIN报文；
7. FIN_WAIT_2： 服务端表示暂时还有数据发送，稍后再关闭连接；
8. TIME_WAIT: 客户端收到FIN报文并发出ACK报文，等待**2MSL**后回到CLOSED；
9. CLOSING: 客户端发送FIN报文，不是先收到服务端的ACK报文，而是收到了FIN报文，即两端同时进行了关闭连接；
10. CLOSE_WAIT: 等待关闭，服务端等待数据发送完的状态；
11. LAST_ACK: 服务端发送FIN 报文后等待ACK报文；
12. CLOSED: 服务端收到ACK报文后，进入CLOSED可用状态


## TCP 重传机制

在异常网络（超市或丢包）时，TCP通过超时重传控制可靠的数据传输。异常情况：

* 发送端发送的数据包丢失；
* 接收端回传ACK包丢失；
* 接收端异常未正常响应，ACK被接收端丢失；

如果发送端没有收到接收端回传的ACK报文，客户端会重发数据，如何设置**重传超时时间(Retransmission TimeOut)**,RTO指客户端发送数据后，重传数据前等待接受方收到该数据
报告ACK的时间。

#### TCP 超时重传

TCP协议必须适应两个方面差异：

* 达到不同目的端的时延差异；
* 统一连接上的传输时延随业务量负载的变化而出现的差异；

TCP协议使用自适应算法以适应分组传输时延的变化，引入了RTT(Round Trip Time)，也就是连接往返时间，发送端发送TCP包到开始到接收它的立即响应所消耗的传输时间。
重传时间为1s, 2s, 4s, 8s，以2的指数级增长。

#### TCP 快重传

超时重传是发送端在傻等超时，然后触发重传；而快速重传则是接收端主动告诉发送端数据没收到，然后触发发送端重传。当客户端收到服务端3次相同ACK报文时，则触发重传。

## TCP 滑动窗口

滑动窗口的作用提供TCP的可靠性和提供TCP的流控特性；TCP窗口是16bit字段，代表窗口的字节容量，也就是TCP标准窗口最大为2^16-1=65535字节

![][3]

* 已收到ack确认的数据。
* 发还没收到ack的。
* 在窗口中还没有发出的（接收方还有空间）。
* 窗口以外的数据（接收方没空间）

通过本端TCP接收窗口大小控制来对端的发送窗口进行流量控制，滑动窗口的实现面向流的可靠性来源于“确认重传”机制。

## TCP 流量控制

流量控制，接收方传递信息给发送方，使其发送数据不要太快，端到端的控制；主要方式是返回的ACK中包含自己接收窗口的大小。利用滑动窗口来实现TCP的流量控制机制。


## TCP 拥塞控制

某段时间内，若对网络中某一个资源的请求超过该资源所能提供的可用部分，网络性能变坏，这种情况叫拥塞。而**拥塞控制**是**防止过多的数据注入网络中**，使网络中的路由器或链路不致过载。

### 慢开始和拥塞避免

发送方维持**拥塞窗口cwnd（congestion windows）**状态变量，窗口大小取决于网络拥塞程度，并且动态变化。

	* 慢启动：刚刚加入网络的连接，由小到大增加cwnd的大小，进行网络提速；刚开始的cwnd=1个MSS,最大报文段长度；
	* 让拥塞窗口缓慢增长，每经过RTT时间发送方的cwnd加1，而不是增倍；

1. cwnd<ssthresh, 使用慢开始算法；
2. cwnd>ssthresh, 使用拥赛避免算法；
3. cwnd=ssthresh, 慢开始和拥塞避免任意；

**ssthresh**表慢开始门限。

![][2]

### 快重传和快恢复

快重传要求接收方收到失序报文段后就立即发出重复确认，而不要等待自己发送数据时捎带确认。 快重传规定发送方只要收到**3个重复确认就立即重传**对方尚未收到的报文段，不必等待重传计时器时间到期。

* 快恢复，发送方接收3个重复确认，执行“乘法减小”算法，慢开始ssthresh减半，预防网络发生阻塞；
* 发送方认为网络可能没发生阻塞，cwnd值设为慢开始门阀减半的值，执行拥塞避免算法（“加法增大”）。


## 思考
* TCP和UDP区别

	TCP是面向连接，可靠的，有序的，缓慢的传输层协议。传输数据之前需通过三次握手建立连接，发送数据无差错，不丢失，不重复。而且发送是字节流
	，并在服务端排序保证数据有序性。因为TCP的各种机制导致传输缓慢，适用于金融方面，点到点通信应用。TCP头部大小20字节。

	UDP是面向无连接，不可靠，无序的，快速传输层协议。传输过程无需建立连接，发送数据报，存在丢包的情况，是一种高速的传输协议，适用于游戏和视频会议
	领域。UDP头部8字节。

* 为什么说TCP是可靠连接？

	TCP发送数据时，要求另外一端返回确认。如果在规定时间没收到确认，那么TCP发送端会重发数据并等待更长时间，数次重传失败后才会放弃。TCP的重传机制保证了可靠性。

* TCP四次分手中，主动关闭方最后为什么要等待2MSL之后才关闭连接？

	* 实现终止TCP全双工连接的可靠性；因为最终的ACK丢失，服务器不得不重发最终的FIN，因此客户端必修维护状态信息允许它重发最终的ACK。
	* 允许老的重复分节在网络中消失；重新建立相同IP地址和端口的TCP连接，TCP防止来自某个连接的老重复分钟再连接终止后重现，TIME_WAIT的持续时间
	为2MSL，足够让某个方向的分钟最多存活MSL秒即被丢弃。

* 为什么是三次握手连接，而不是二次连接？
	
	防止失效的请求报文段又传送到服务端，造成服务端资源浪费。
	客户端发起的连接请求由于网络时延没能及时达到服务器，而客户端等待一段时间重新发送连接请求且建立成功。 而过后失效的连接请求到达服务器，服务器以为是客户端又重新发送的新连接，服务端同意连接并向客户端发回确认。此时客户端不予理会，从而服务端等待客户端发送数据，造成了服务端资源浪费。

* 为什么是四次断开连接，而不是三次断开？
	
	关闭连接时，客户端发送FIN报文给服务端，仅仅表示客户端没有数据发送给服务端了。但此时服务端可能数据还没传输完，所以不能立即关闭连接，需要发送ACK表示关闭请求已经收到，待服务端发送完数据给客户端后再发送FIN报文表示服务端也要关闭连接，此时客户端再发回ACK，表示成功关闭连接。

## TCP 网络编程

  TODO

[1]: tcp_state.png
[2]: slow_start.jpg
[3]: slide_window.png

---

【资料】：
【1】：http://blog.csdn.net/kinger0/article/details/48206999

## set

set是关联性容器，存储同一数据类型的数据，set中每个元素的值唯一，而且能根据元素自动排序。c++中set, multiset, map, multimap内部采用都是红色树实现。

std::set<int> IntSet;

### 问题

### 为何map和set的插入效率比其他序列容器高？

因为关联容器不用做内存拷贝和移动，前面说的set是树形结构，即节点结构有左孩子和右孩子，插入的时候，只需要更改指针的值，指向新的地址。
删除也是一样的道理。一切都是修改指针变量，和内存移动无关。

### 为何每次insert之后，以前保存的迭代器不会失效？

set的迭代器是指向当前元素的指针，也就是地址。set中元素的内存没有变，所以指针也就不会变。而在vector中，capacity()会预留申请一个内存空间，
如果当前空间不够，那么回重新申请一段内存空间，可能会清除以前的内存，把内存中的内容拷贝到新的内存空间。

### 当数据元素增多时，set的插入和搜索速度变化如何？

因为set是平衡二叉树，所以左值小于根节点，右孩子大于根节点。那么查找的话，也就是二分查找，执行效率也就是logN的时间，所以元素增多，查找时间也是很可观的。
